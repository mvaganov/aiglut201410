aiglut201410
============

a C / C++ game using freeGLUT. Intended for student use, using Microsoft Visual Studio (Express) 2012 or higher.

lesson plan TODO:
//---wk1day1 --- new project!
// basic game loop (display/input/update)
// draw colored lines and circle
// mouse and key input
// draw line, circle, rect, box
// test contains for circle, rect, box
// create list of objects using polymorphism
// create random list of agents
// RNG
// create and draw agents
// select agents with mouse
// set velocity of selected agent (separate from direction)

//---wk1day2 --- basic steering behavior
// changing the direction of agents to match velocity
// vector practice - make agents look different (radius pointing in dir, googly eyes, with beaks, other?)
// player moves (seek)
/*
vec2 seek(vec2 target, Agent agent) {
	vec2 desired = target - agent.position;
	desired *= agent.maxSpeed / desired.mag();
	vec2 force = desired - agent.velocity;
	return force * (agent.maxForce / agent.maxSpeed);
}
*/
// agents collide with obstacles
// player attacks with dangerous projectiles
// destroying objects and managing memory
// player deals damage to ai
// ai gets killed
/*
	...
	#include <crtdbg.h>
	int main(int argc, char * argv[]) {
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);
	...
*/

//---wk2day3 --- fuzzy state machines for multiple steering impulses
// flee
// steering behavior namespace
// random-walk <-- student assignment
// ai seeks plyaer and flees projectiles
	// pursue
	// evade
	// offset pursuit
// player moves (arrive) <-- student assignment
/*
float stopDistance(float speed, float acceleration) {
	return (speed*speed)/(2*acceleration);
}
vec2 arrive(vec2 target, Agent agent, int a_ms) {
	if(distance(agent.position, target) <= stopDistance(agent.velocity.mag(), agent.maxForce)) {
		return stop(agent, a_ms);
	} else {
		return seek(target, agent);
	}
}
*/
// ai conflicting ai moves
// fuzzy logic
// introduce finite state machine
// begin implementing finite state machine

//---wk2day4 --- environment aware steering behaviors (more fuzzy logic)
// implement finite state machine
// obstacles
// obstacle collision detection
// ai avoid obstacles
	// ai avoid other ai agents
	// ai try to keep some sort of comfort zone
// ai flee behind cover when low on HP

//---wk3day5 --- finite state machines
// ai follows you when you get in range
// ai flees when low on hp
// ai regenerates HP
// ai heal each other when close
	// loneliness meter causes ai to seek out friendlies, which reduces loneliness
	// aggressive meter causes ai to attack if player (or other AI) in range
	// hungriness meter causes ai to seek out food resources

//---wk3day6 --- graph navigation
// create a graph
// draw the nav graph
// ai move using the nav graph (A*)

//---wk4day7 --- group behavior
// ai separation
/*
vec2 Separation(Agent agent, List<Agent> neighbors) {
	if (neighbors.empty())	return	vec2.zero;
	vec2 totalForce = vec2.zero;
	for (Agent neighbor : neighbors) {
		vec2 pushForce = (agent.pos - neighbor.pos)
		totalForce += 1 - (pushForce / agent.neighborRadius);
	}
	totalForce /= neighbors.count();
	totalForce *= agent.maxForce;
}
*/
// ai cohesion
/*
vec2 Cohesion(Agent agent, List<Agent> neighbors) {
	if (neighbors.empty()) return vec2.zero;
	vec2 centerOfMass = agent.position;
	for (Agent neighbor : neighbors)
		centerOfMass +=	neighbor.position;
	centerOfMass /=	neighbors.count();
	vec2 desired =	centerOfMass - agent.position;
	desired	*= agent.maxSpeed / desired.mag();
	vec2 force = desired - agent.velocity;
	return force * (agent.maxForce / agent.maxSpeed);
}
*/
// ai alignment
/*
vec2 Alignment(Agent agent, List<Agent> neighbors) {
	if (neighbors.empty()) return vec2.zero;
	vec2 avgHeading = norm( agent.velocity );
	for (Agent neighbor : neighbors)
		avgHeading += norm( neighbor.velocity );
	avgHeading /= neighbors.count();
	vec2 desired = avgHeading * agent.maxSpeed;
	vec2 force = desired - agent.velocity;
	return force * (agent.maxForce / agent.maxSpeed);
}
*/
// ai flocking

//---wk4day8 --- midterm review

//---wk5day9 --- midterm

//---wk6day10 --- game project pep talk
	//game project
		// implement your own steering behaviors (seek, flee, arrive, obstacle avoidance, path finding with A*)
		// pusruit, evasion, hide, flocking
	// markov chain

//---wk6day11 --- behavior trees
//---wk7day12 --- genetic algorithm, gini impurity, neural network
//---wk7day13 --- project presentations
